



TODO Working Group                                             C. Patton
Internet-Draft                                                Cloudflare
Intended status: Informational                         20 September 2021
Expires: 24 March 2022


        Multi-party Protocols for Privacy-preserving Measurement
                     draft-patton-multi-ppm-latest

Abstract

   [TODO Move and rename this document to "draft-patton-vdaf".]  This
   document describes Verifiable Distributed Aggregation Functions
   (VDAFs), a family of multi-party protocols for computing aggregate
   statistics over user measurements.  These protocols are designed to
   ensure that, as long as at least one aggregation server executes the
   protocol honestly, individual measurements are never seen by any
   server in the clear.  At the same time, VDAFs allow the servers to
   detect if a misconfigured or malicious client submitted a malformed
   input.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the mailing list (), which
   is archived at .

   Source for this draft and an issue tracker can be found at
   https://github.com/cjpatton/ppm.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 24 March 2022.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Distributed Aggregation Functions
     3.1.  Aggregability
   4.  Verifiable Distributed Aggregation Functions
   5.  Security Considerations
   6.  IANA Considerations
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   TODO Introduction

   VDAFs from the literature:

   *  Prio [CGB17] defines the composition of a linear secret sharing
      scheme and an affine-aggregatable encoding of a statistic.

   *  A special case of zero-knowledge proofs over distributed data
      [BBDGGI19] in which the client speaks once.

   *  The composition of an incremental distributed point function and
      the secure-sketching protocol for subset histograms defined in
      [BBDGGI21].

   *  Prio+ [AGJOP21] has the client upload XOR shares and then has the
      servers convert them to additive shares over a number of rounds.

   This document is structured as follows.

   *  Section 3 defines Distributed Aggregation Functions (DAFs), which
      distribute the computation of an aggregation function among a set
      of aggregators in order to keep the inputs private.

   *  Section 4 defines Verifiable Distributed Aggregation Functions
      (VDAFs), an extension of DAFs that additionally allow the
      aggregators to detect malformed inputs.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

   Algorithms are written in Python 3.  Unless noted otherwise, function
   parameters without a type hint have type "bytes".  A fatal error in a
   program (e.g., failure to parse one of the function parameters) is
   usually handled by raising an exception.

3.  Distributed Aggregation Functions

   client
     | input
     v
   +-----------------------------------------------------------+
   | dist_input()                                              |
   +-----------------------------------------------------------+
     | input_shares[1]  | input_shares[2]   ...  | input_shares[s]
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_output() |  | dist_output() |        | dist_output() |
   +---------------+  +---------------+        +---------------+
     | output_shares[1] | output_shares[2]  ...  | output_shares[s]
     v                  v                        v
   aggregator 1       aggregator 2             aggregator s

                Figure 1: Execution of an s-aggregator DAF.

   A DAF is a multi-party protocol for executing an aggregation function
   over a set of user inputs.  By distributing the input across multiple
   aggregators, the protocol ensures that individual inputs are never
   seen in the clear.  Syntactically, an "s"-aggregator DAF is made up
   of two algorithms:

   *  "dist_input(input) -> input_shares" is the randomized input-
      distribution algorithm.  It is run by the client in order to split
      its input into "s" input shares, where "s" is the number of
      aggregators (i.e., "len(input_shares) == s").  Note that "s" is a
      parameter of, and fixed by, the DAF.

   *  "dist_output(param, input_share) -> output_share" is the
      deterministic output-recovery algorithm.  It is run be each
      aggregator in order to map an input share to an output share.
      This mapping has a parameter "param", which can be used to "query"
      the input share multiple times with multiple parameters, getting a
      different output share each time. "param" is called the
      aggregation parameter.

   Execution of a DAF is illustrated in Figure 1.  The client runs the
   input-distribution algorithm and sends an input share to each one of
   the aggregators.  Next, the aggregators select a parameter for
   querying the input shares, and each runs the output-recover algorithm
   to obtain their share of the output.  DAF schemes are designed to
   ensure that no proper subset of the aggregators can discern any
   information about the input or output given their view of the
   protocol.  (See Section 5.)

3.1.  Aggregability

   Let "G[param]" denote the support of the output-recovery algorithm
   for a given aggregation parameter "param".  That is, set "G[param]"
   contains the set of all possible outputs of "dist_output" when the
   first input is "param" and the second is any input share.

   Correctness requires that, for every aggregation parameter "param",
   the set "G[param]" forms an additive group.  This allows the
   aggregation function to be computed by having each aggregator sum up
   its output shares locally, then collectively computing the output by
   summing up their aggregated output shares.  In particular, the
   aggregation function is computed by the following algorithm. (let
   "Zero[param]" be the identity element of "G[param]"):

   def RunDAF(param, inputs):
     output_shares = [ Zero[param] for j in range(s) ]

     for input in inputs:
       # Each client runs the input-distribution algorithm.
       inputs_shares = dist_input(input)

       # Each aggregator runs the output-recvoery algorithm.
       for j in range(s):
         output_shares[j] += dist_output(param, input_shares[j])

     # Aggregators compute the final output.
     return sum(output_shares)

      Figure 2: Definition of the aggregation function computed by an
                             s-aggregator DAF.

4.  Verifiable Distributed Aggregation Functions

   client
     | input
     v
   +-----------------------------------------------------------+
   | dist_input()                                              |
   +-----------------------------------------------------------+
     | input_shares[1]  | input_shares[2]   ...  | input_shares[s]
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_start()  |  | dist_start()  |        | dist_start()  |
   +---------------+  +---------------+        +---------------+
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_next_2() |  | dist_next_2() |        | dist_next_2() |
   +---------------+  +---------------+        +---------------+
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
     .                  .                        .
     .                  .                        .
     .                  .                        .
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_finish() |  | dist_finish() |        | dist_finish() |
   +---------------+  +---------------+        +---------------+
     | output_shares[1] | output_shares[2]  ...  | output_shares[s]
     v                  v                        v
   aggregator 1       aggregator 2             aggregator s

       Figure 3: Execution of an r-round, s-aggregator VDAF.  The ===
                    line represents a broadcast channel.

   The main limitation of DAF schemes is that, because each aggregator
   only holds a piece of the distributed input, there is no way for them
   to check that the output is valid without revealing their shares to
   one another.  A VDAF is an extension of a DAF in which the
   aggregators verify that the output is valid before recovering their
   output shares.  Doing so requires the aggregators to interact with
   one another, which they do over a broadcast channel.

   Execution of a VDAF is illustrated in Figure 3.  It begins just as
   before (see Figure 1) by having the client run the input-distribution
   algorithm and send an input share to each of the aggregators.  The
   aggregators then proceed in rounds, where in each round, each
   aggregator produces a single outbound message.  The outbound messages
   are written to a broadcast channel, then broadcast to all of the
   aggregators to begin the next round.  Eventually, each aggregator
   decides if the input shares are valid based on its view of the
   protocol.  If so, it returns an output share.  Otherwise it returns
   an indication of invalidity.

   Syntactically, an "r"-round, "s"-aggregator VDAF is made up of the
   following algorithms:

   *  "dist_input(input) -> input_shares" is the input-distribution
      algorithm defined precisely the same way as Section 3.

   *  "dist_init(param) -> states" is the state-initialization
      algorithm.  It takes as input the aggregation parameter and
      outputs the initial state of each aggregator (i.e., "len(states)
      == s").  This algorithm is executed out-of-band and is used to
      configure the aggregators with whatever they need to run the
      protocol (e.g., shared randomness).

   *  "dist_start(state, input_share) -> (new_state, outbound_message)"
      is the verify-start algorithm and is run by each aggregator in
      response to an input share from the client.  Its output is the
      aggregator's first outbound message to be broadcast to the other
      aggregators.

   *  "dist_next_i(state, inbound_messages) -> (new_state,
      outbound_message)" is used to consume the "(i-1)"-th round of
      inbound messages (note that "len(inbound_messages) == s") and
      produces the aggregator's "i"-th outbound message.  The protocol
      specifies such a function for every "2 <= i <= r"; if "r == 1",
      then this function is not defined.

   *  "dist_finish(state, inbound_messages) -> output_share" is the
      verify-finish algorithm.  It consumes the "r"-th round of inbound
      messages (note that "len(inbound_messages) == s") and produces the
      aggregator's output share, or an indication that the input shares
      are invalid.

   Like DAFs, the number of aggregators "s" is a parameter of the
   scheme.  Similarly, the number of rounds "r" is a constant specified
   by the VDAF.

   Just as for DAF schemes, we require that for each aggregation
   parameter "param", the set of output shares "G[param]" forms an
   additive group.  The aggregation function is computed by running the
   VDAF as specified below (let "Zero[param]" denote the additive
   identity of "G[param]"):

   def RunVDAF(param, inputs):
     output_shares = [ `Zero[param] for j in range(s) ]

     for input in inputs:
       # Each client runs the input-distribution algorithm.
       inputs_shares = dist_input(input)

       # Aggregators verify and recover their output shares.
       states = dist_init(param)

       outbound = []
       for j in range(s):
         (states[j], msg) = dist_start(states[j], input_shares[j])
         outbound.append(msg)
       inbound = outbound

       for i in range(r-1):
         outbound = []
         for j in range(s):
           (states[j], msg) = dist_next_i(states[j], inbound)
           outbound.append(msg)
         inbound = outbound

       for j in range(s):
         output_share[j] += dist_finish(states[j], inbound)

     # Aggregators compute the final output.
     return sum(output_shares)

           Figure 4: Execution of an r-round, s-aggregator VDAF.

5.  Security Considerations

   TODO There will be a companion paper [PAPER] that will formalize the
   syntax and security of VDAFs and analyze some of the constructions
   specified here.  Here we will say at a high level what completeness,
   soundness, and privacy (i.e., zero-knowledge) are.

   Things that are out of scope:

   *  Sybil attacks [Dou02]

   *  Differential privacy [Vad16]

6.  IANA Considerations

   This document has no IANA actions.

7.  References

7.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

7.2.  Informative References

   [AGJOP21]  Addanki, S., Garbe, K., Jaffe, E., Ostrovsky, R., and A.
              Polychroniadou, "Prio+: Privacy Preserving Aggregate
              Statistics via Boolean Shares", 2021,
              <https://ia.cr/2021/576>.

   [BBDGGI19] Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., and
              Y. Ishai, "Zero-Knowledge Proofs on Secret-Shared Data via
              Fully Linear PCPs", CRYPTO 2019 , 2019.

   [BBDGGI21] Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., and
              Y. Ishai, "Lightweight Techniques for Private Heavy
              Hitters", IEEE S&P 2021 , 2021.

   [CGB17]    Corrigan-Gibbs, H. and D. Boneh, "Prio: Private, Robust,
              and Scalable Computation of Aggregate Statistics", NSDI
              2017 , 2017.

   [Dou02]    Douceur, J., "The Sybil Attack", 2002,
              <https://link.springer.com/
              chapter/10.1007/3-540-45748-8_24>.

   [GI14]     Gilboa, N. and Y. Ishai, "Distributed Point Functions and
              Their Applications", EUROCRYPT 2014 , 2014.

   [PAPER]    "TODO", n.d..

   [Vad16]    Vadhan, S., "The Complexity of Differential Privacy",
              2016,
              <https://privacytools.seas.harvard.edu/files/privacytools/
              files/complexityprivacy_1.pdf>.

Acknowledgments

   TODO acknowledge.

Author's Address

   Christopher Patton
   Cloudflare

   Email: chrispatton+ietf@gmail.com
