



TODO Working Group                                             C. Patton
Internet-Draft                                                Cloudflare
Intended status: Informational                         17 September 2021
Expires: 21 March 2022


        Multi-party Protocols for Privacy-preserving Measurement
                     draft-patton-multi-ppm-latest

Abstract

   Various multi-party protocols for computing aggregate statistics over
   client measurements are described.  Based on secret sharing, these
   protocols are designed to ensure that individual client measurements
   are never seen in the clear as long as at least one data aggregation
   servers executes the protocol honestly.  Some of the protocols also
   allow the servers to detect cheating clients using zero-knowledge
   proof techniques.

Discussion Venues

   This note is to be removed before publishing as an RFC.

   Discussion of this document takes place on the mailing list (), which
   is archived at .

   Source for this draft and an issue tracker can be found at
   https://github.com/cjpatton/ppm.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at https://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on 21 March 2022.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents (https://trustee.ietf.org/
   license-info) in effect on the date of publication of this document.
   Please review these documents carefully, as they describe your rights
   and restrictions with respect to this document.  Code Components
   extracted from this document must include Simplified BSD License text
   as described in Section 4.e of the Trust Legal Provisions and are
   provided without warranty as described in the Simplified BSD License.

Table of Contents

   1.  Introduction
   2.  Conventions and Definitions
   3.  Distributed Aggregation Functions
     3.1.  Aggregability
   4.  Verifiable Distributed Aggregation Functions
   5.  Security Considerations
   6.  IANA Considerations
   7.  References
     7.1.  Normative References
     7.2.  Informative References
   Acknowledgments
   Author's Address

1.  Introduction

   TODO Introduction

   VDAFs from the literature:

   *  Prio [CGB17] defines the composition of a linear secret sharing
      scheme and an affine-aggregatable encoding of a statistic.

   *  A special case of zero-knowledge proofs over distributed data
      [BBCGp19] in which the client speaks once.

   *  The composition of an incremental DPF and the secure-sketching
      protocol for subset histograms defined in [BBCGp19].

   *  Prio+ [AGJp21] has the client upload XOR shares and then has the
      servers convert them to additive shares over a number of rounds.

2.  Conventions and Definitions

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and
   "OPTIONAL" in this document are to be interpreted as described in
   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all
   capitals, as shown here.

3.  Distributed Aggregation Functions

   client
     | input
     v
   +-----------------------------------------------------------+
   | dist_input()                                              |
   +-----------------------------------------------------------+
     | input_shares[1]  | input_shares[2]   ...  | input_shares[s]
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_output() |  | dist_output() |        | dist_output() |
   +---------------+  +---------------+        +---------------+
     | output_shares[1] | output_shares[2]  ...  | output_shares[s]
     v                  v                        v
   aggregator 1       aggregator 2             aggregator s

                Figure 1: Execution of an s-aggregator DAF.

   A "Distributed Aggregation Function (DAF)" is a multi-party protocol
   for executing an aggregation function over a set of user inputs.  By
   distributing the input across multiple aggregators, the protocol
   ensures that individual inputs are never seen in the clear.
   Syntactically, an "s"-aggregator DAF is made up of two algorithms:

   *  "dist_input(input) -> input_shares" is the randomized input-
      distribution algorithm.  It is run by the client in order to split
      its input into "s" input shares, where "s" is the number of
      aggregators (i.e., "len(input_shares) == s").  The sequence of
      input shares is also referred to as the distributed input.

   *  "dist_output(param, input_share) -> output_share" is the
      deterministic output-recovery algorithm.  It is run be each
      aggregator in order to map an input share to an output share.
      This mapping has an optional parameter, which can be used to
      "query" the input share multiple times, getting a different output
      share each time.  We call this the aggregation parameter.

   Execution of a DAF is illustrated in Figure 1.  The client runs the
   input-distribution algorithm and sends an input share to each one of
   the aggregators.  The aggregators select a parameter for querying the
   input shares, then each runs the output-recover algorithm to obtain
   their share of the output.  DAF schemes are designed to ensure that
   no proper subset of the aggregators can discern any information about
   the input or output given their view of the protocol.  (See
   Section 5.)

3.1.  Aggregability

   Let "O[param]" denote the support of the output-recovery algorithm
   for a given aggregation parameter "param".  That is, set "O[param]"
   contains the set of all possible outputs of "dist_output" when the
   first input is "param" and the second is any input share.

   Our applications require that for every aggregation parameter
   "param", the set "O[param]" forms an additive group.  This allows the
   aggregation function to be computed by having each aggregator sum up
   its output shares locally, then having the aggregators collectively
   compute the output by summing up their aggregated output shares.  In
   particular, the aggregation function is computed over a set of inputs
   "inputs" and an aggregation parameter "param" by running the
   following algorithm:

   def RunDAF(param, inputs):
     output_shares = [ 0 for j in range(s) ]

     for input in inputs:
       # Each client runs the input-distribution algorithm.
       inputs_shares = dist_input(input)

       # Each aggregator runs the output-recvoery algorithm.
       for j in range(s):
         output_shares[j] += dist_output(param, input_shares[j])

     # Aggregators compute the final output.
     return sum(output_shares)

      Figure 2: Definition of the aggregation function computed by an
                             s-aggregator DAF.

4.  Verifiable Distributed Aggregation Functions

   client
     | input
     v
   +-----------------------------------------------------------+
   | dist_input()                                              |
   +-----------------------------------------------------------+
     | input_shares[1]  | input_shares[2]   ...  | input_shares[s]
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_start()  |  | dist_start()  |        | dist_start()  |
   +---------------+  +---------------+        +---------------+
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_next_2() |  | dist_next_2() |        | dist_next_2() |
   +---------------+  +---------------+        +---------------+
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
     .                  .                        .
     .                  .                        .
     .                  .                        .
     |                  |                   ...  |
     =============================================
     |                  |                        |
     v                  v                        v
   +---------------+  +---------------+        +---------------+
   | dist_finish() |  | dist_finish() |        | dist_finish() |
   +---------------+  +---------------+        +---------------+
     | output_shares[1] | output_shares[2]  ...  | output_shares[s]
     v                  v                        v
   aggregator 1       aggregator 2             aggregator s

       Figure 3: Execution of an r-round, s-aggregator VDAF.  The ===
                    line represents a broadcast channel.

   The main limitation of DAF schemes is that, because Because each
   aggregator only holds a piece of the distributed input, there is no
   way for them to check that the output is valid without revealing
   their shares to one another.  A "Verifiable Distributed Aggregation
   Function (VDAF)" is an extension of a DAF in which the aggregators
   verify that the output is valid before recovering their output
   shares.

   Execution of a VDAF is illustrated in Figure 3.  It begins just as
   before (see Figure 1) by having the client run the input-distribution
   algorithm and send an input share to each of the aggregators.  The
   aggregators then proceed in rounds, where in each round, each
   aggregator produces a single outbound message.  The outbound messages
   are written to a broadcast channel, then broadcast to all of the
   aggregators to begin the next round.  Eventually, each aggregator
   decides if the input shares are valid based on its view of the
   protocol.  If so, it returns an output share.  Otherwise it returns
   an indication of invalidity.

   Syntactically, an "r"-round, "s"-aggregator VDAF is made up of the
   following algorithms:

   *  "dist_input(input) -> input_shares" is the input-distribution
      algorithm defined precisely the same way as Section 3.

   *  "dist_init(param) -> states" is the state-initialization
      algorithm.  It takes as input the aggregation parameter and
      outputs the initial state of each aggregator (i.e., "len(states)
      == s").  This algorithm is executed out-of-band and is used to
      configure the aggregators with whatever they need to run the
      protocol (e.g., shared randomness).

   *  "dist_start(state, input_share) -> (new_state, outbound_message)"
      is the verify-start algorithm and is run by each aggregator in
      response to an input share from the client.  Its output is the
      aggregator's first outbound message to be broadcast to the other
      aggregators.

   *  "dist_next_i(state, inbound_messages) -> (new_state,
      outbound_message)" is used to consume the "(i-1)"-th round of
      inbound messages (i.e., "len(inbound_messages) == s") and produces
      the aggregator's "i"-th outbound message.  The protocol specifies
      such a function for every "1 < i <= r"; if "r == 1", then this
      function is not defined.

   *  "dist_finish(state, inbound_messages) -> output_share" is the
      verify-finish algorithm.  It consumes the "r"-th round of inbound
      messages (i.e., "len(inbound_messages) == s") and produces the
      aggregator's output share, or an indication that the input shares
      are invalid.

   As for DAF schemes, we require that for each aggregation parameter
   "param", the set of output shares "O[param]" forms an additive group.
   The aggregation function is computed by running the VDAF as specified
   below.

   def RunVDAF(param, inputs):
     output_shares = [ 0 for j in range(s) ]

     for input in inputs:
       # Each client runs the input-distribution algorithm.
       inputs_shares = dist_input(input)

       # Aggregators recover their output shares.
       states = dist_init(param)

       outbound = []
       for j in range(s):
         (states[j], msg) = dist_start(states[j], input_shares[j])
         outbound.append(msg)
       inbound = outbound

       for i in range(r-1):
         outbound = []
         for j in range(s):
           (states[j], msg) = dist_next_i(states[j], inbound)
           outbound.append(msg)
         inbound = outbound

       for j in range(s):
         output_share[j] += dist_finish(states[j], inbound)

     return sum(output_shares)

           Figure 4: Execution of an r-round, s-aggregator VDAF.

5.  Security Considerations

   TODO There will be a companion paper [PAPER] that will formalize the
   syntax and security of VDAFs and analyze some of the constructions
   specified here.  Here we will say at a high level what completeness,
   soundness, and privacy (i.e., zero-knowledge) are.

6.  IANA Considerations

   This document has no IANA actions.

7.  References

7.1.  Normative References

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119,
              DOI 10.17487/RFC2119, March 1997,
              <https://datatracker.ietf.org/doc/html/rfc2119>.

   [RFC8174]  Leiba, B., "Ambiguity of Uppercase vs Lowercase in RFC
              2119 Key Words", BCP 14, RFC 8174, DOI 10.17487/RFC8174,
              May 2017, <https://datatracker.ietf.org/doc/html/rfc8174>.

7.2.  Informative References

   [AGJp21]   Addanki, S., Garbe, K., Jaffe, E., Ostrovsky, R., and A.
              Polychroniadou, "Prio+: Privacy Preserving Aggregate
              Statistics via Boolean Shares", 2021,
              <https://ia.cr/2021/576>.

   [BBCGp19]  Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., and
              Y. Ishai, "Zero-Knowledge Proofs on Secret-Shared Data via
              Fully Linear PCPs", CRYPTO 2019 , 2019.

   [BBCGp21]  Boneh, D., Boyle, E., Corrigan-Gibbs, H., Gilboa, N., and
              Y. Ishai, "Lightweight Techniques for Private Heavy
              Hitters", IEEE S&P 2021 , 2021.

   [CGB17]    Corrigan-Gibbs, H. and D. Boneh, "Prio: Private, Robust,
              and Scalable Computation of Aggregate Statistics", NSDI
              2017 , 2017.

   [GI14]     Gilboa, N. and Y. Ishai, "Distributed Point Functions and
              Their Applications", EUROCRYPT 2014 , 2014.

   [PAPER]    "TODO", n.d..

Acknowledgments

   TODO acknowledge.

Author's Address

   Christopher Patton
   Cloudflare

   Email: chrispatton+ietf@gmail.com
