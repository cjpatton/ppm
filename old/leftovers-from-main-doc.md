

# OLD CRYPTO TEXT THAT PROBABLY GOES IN ANOTHER DOC


## Definition flow

Each PPM task consists of two sub-protocols, *upload* and *collect*, which are
executed concurrently. Each sub-protocol consists of a sequence of HTTP requests
made from one entity to another.

## Private aggregation via secret sharing

The main cryptographic tool used for achieving this privacy goal is *additive
secret sharing*. Rather than send its input in the clear, each client splits
its measurements into a sequence of *shares* and sends a share to each of the
aggregators. Additive secret sharing has two important properties:

- It's impossible to deduce the measurement without knowing *all* of the shares.
- It allows the aggregators to compute the final output by first adding up their
  measurements shares locally, then combining the results to obtain the final
  output.

Consider an illustrative example. Suppose there are three clients and two
aggregators. Each client `i` holds a single measurement in the form of a
positive integer `x[i]`, and our goal is to compute the sum of the measurements
of all clients. In this case, the protocol input is a single measurement
consisting of a single positive integer; no additional encoding is done. Given
this input, the first client splits its measurement `x[1]` with additive
secret-sharing into a pair of integers `X[1,1]` and `X[1,2]` for which `x[1]` is
equal to `X[1,1] + X[1,2]` modulo a prime number `p`. (For convenience, we will
omit the mod `p` operator in the rest of this section.) It then uploads `X[1,1]`
to one server and `X[1,2]` to the other. The second client splits its
measurement `x[2]` into `X[1,2]` and `X[2,2]`, uploads them to the servers, and
so on.

Now the first aggregator is in possession of shares `X[1,1]`, `X[2,1]`, and
`X[3,1]` and the second aggregator is in possession of shares `X[2,1]`,
`X[2,2]`, and `X[2,3]`. Each aggregator computes the sum of its shares; let
`A[1]` denote the first aggregator's share of the sum and let `A[2]` denote the
second aggregator's share of the sum. In the last step, aggregators combine
their sum shares to obtain the final output `y = A[1] + A[2]`. This is correct
because modular addition is commutative. I.e.,

~~~
    y = A[1] + A[2]
      = (x[1,1] + x[2,1] + x[3,1]) + (x[1,2] + x[2,2] + x[3,2])
      = (x[1,1] + x[1,2]) + (x[2,1] + x[2,2]) + (x[3,1] + x[3,2])
      = x[1] + x[2] + x[3]
      = F(x[1], x[2], x[3])
~~~

### Prio {#prio-variant}

This approach can be used to privately compute any function `F` that can be
expressed as a function of the sum of the users' inputs. In Prio {{CB17}}, each
user splits its input into shares and sends each share to one of the
aggregators. The aggregators sum up their input shares. Once all the shares have
been aggregated, they combine their shares of the aggregate to get the final
output.

Not all aggregate functions can be expressed this way efficiently, however. Prio
supports only a limited set of aggregation functions, some of which we highlight
below:

- Simple statistics, like sum, mean, min, max, variance, and standard deviation;
- Histograms with fixed bin sizes (also allows estimation of quantiles, e.g.,
  the median);
- More advanced statistics, like linear regression;
- Bitwise-OR and -AND on bit strings; and
- Computation of data structures, like Bloom filters, counting Bloom filters,
  and count-min sketches, that approximately represent (multi-)sets of strings.

This variety of aggregate types is sufficient to support a wide variety of
data aggregation tasks.

### Hits {#hits-variant}

A common PPM task that can't be solved efficiently with Prio is the
`t`-*heavy-hitters* problem {{BBCp21}}. In this setting, each user is in
possession of a single `n`-bit string, and the goal is to compute the compute
the set of strings that occur at least `t` times. One reason that Prio doesn't
apply to this problem is that the proof generated by the client would be huge.

[TODO: Provide an overview of the protocol of {{BBCp21}} and provide some
intuition about how additive secret sharing is used.]



## Parameters

### Finite field arithmetic

The algorithms that comprise the input-validation protocol --- Prove, Query, and
Decide --- are constructed by generating and evaluating polynomials over a
finite field. As such, the main ingredient of Prio is an implementation of
arithmetic in a finite field suitable for the given application.

We will use a prime field. The choice of prime is influenced by the following
criteria:

1. **Field size.** How big the field needs to be depends on the type of data
   being aggregated and how many users there are. The field size also impacts
   the security level: the longer the validity circuit, the larger the field
   needs to be in order to effectively detect malicious clients. Typically the
   soundness error (i.e., the probability of an invalid input being deemed valid
   by the aggregators) will be 2n/(p-n), where n is the size of the input and p
   is the prime modulus.
1. **Fast polynomial operations.** In order to make Prio practical, it's
   important that implementations employ FFT to speed up polynomial operations.
   In particular, the prime modulus p should be chosen so that `(p-1) = 2^b * s`
   for large `b` and odd `s`. Then `g^s` is a principle, `2^b`-th root of unity
   (i.e., `g^(s\*2^b) = 1`), where `g` is the generator of the multiplicative
   subgroup.
   This fact allows us to quickly evaluate and interpolate polynomials at
   `2^a`-th roots of unity for any `1 <= a <= b`. Note that `b` imposes an upper
   bound on the size of proofs, so it should be large enough to accommodate all
   foreseeable use cases. Something like `b >= 20` is probably good enough.
1. **As close to a power of two as possible.** We use rejection sampling to map
   a PRNG seed to a pseudorandom sequence of field elements (see {{prio-prng}).
   In order to minimize the probability of a simple being rejected, the modulus
   should be as close to a power of 2 as possible.
1. **Code optimization.** [[TODO: What properties of the field make
   it possible to write faster implementations?]]

The table below lists parameters that meet these criteria at various
levels of security. The "size" column indicates the number of bits
required to represent elements of the field.

| # | size | p                                      | g  | b   | s                |
|---|------|----------------------------------------|----|-----|------------------|
| 1 | 32   | 4293918721                             | 19 | 20  | 3^2 * 5 * 7 * 13 |
| 2 | 64   | 15564440312192434177                   | 5  | 59  | 3^3              |
| 3 | 80   | 779190469673491460259841               | 14 | 72  | 3 * 5 * 11       |
| 4 | 123  | 9304595970494411110326649421962412033  | 3  | 120 | 7                |
| 5 | 126  | 74769074762901517850839147140769382401 | 7  | 118 | 3^2 * 5^2        |

[TODO: Choose new parameters for 2, 3, and 5 so that p is as close to 2^size as
possible without going over. (4 is already close enough; 1 is already deployed
and can't be changed.]

**Finding suitable primes.**
One way to find suitable primes is to first choose `b`, then "probe" to find a
prime of the desired size. The following SageMath script prints the parameters
of a number of (probable) primes larger than `2^b` for a given `b`:

~~~
b = 116
for s in range(0,1000,1):
    B = 2^b
    p = (B*s).next_prime()
    if p-(B*s) == 1:
        bits = round(math.log2(p), 2)
        print(bits, p, GF(p).multiplicative_generator(), b, factor(s))
~~~

### Pseudorandom number generation {#prio-prng}

A suitable PRNG will have the following syntax. Fix a finite field `K`:

1. `x := PRNG(k, n)` denotes generation of a vector of `n` elements of `K`.

This can be instantiated using a standard stream cipher, e.g., AES-CTR, as
follows. Interpret the seed `k` as the key and IV for generating the AES-CTR key
stream. Proceed by rejection sampling, as follows. Let `m` be the number of bits
needed to encode an element of `K`. Generate the next `m` bits of key stream and
interpret the bytes as an integer `x`, clearing the most significant `m - l`
bits, where `l` is the bit-length of the modulus `p`. If `x < p`, then output
`x`. Otherwise, generate the next `m` bits of key stream and try again. Repeat
this process indefinitely until a suitable output is found.

## Pre-conditions

We assume the following conditions hold before execution of any PPM task begins:

1. The clients, aggregators, and collector agree on a set of PPM tasks, as well
   as the PPM parameters associated to each task.
1. Each aggregator has a clock that is roughly in sync with true time, i.e.,
   within the batch window specified by the PPM parameters. (This is necessary to
   prevent the same report from appearing in multiple batches.)
1. Each client has selected a PPM task for which it will upload a report. It is
   also configured with the task's parameters.
1. Each client and the leader can establish a leader-authenticated secure
   channel.
1. The leader and each helper can establish a helper-authenticated secure
   channel.
1. The collector and leader can establish a leader-authenticated secure channel.
1. The collector has chosen an HPKE configuration and corresponding secret key.
1. Each aggregator has chosen an HPKE configuration and corresponding secret key.

[TODO: It would be clearer to include a "pre-conditions" section prior to each
"phase" of the protocol.]

